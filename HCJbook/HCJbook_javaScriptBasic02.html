<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>js객체</title>
  <script>
    //객체 상수(리터럴방식)로부터 객체 생성
    //간단하지만 객체를 하나만 생성할수있고 추가로 객체 생성시,
    //동일한 코드 반복해야해서 싱글톤(객체가 하나만생성)이라부른다.
    let myCarEx01 = {
      modelCar: `moning`,//객체의 속성
      speedCar: 150,
      colorCar: `black`,
      brakeCar: function () { this.speedCar -= 10 },//객체의 메서드
      accelCar: function () { this.speedCar += 10 },
    }
    myCarEx01.colorCar = `white`;//객체 속성 변경
    console.log(myCarEx01.colorCar);
    myCarEx01.brakeCar()//브레이크 함수 실행
    console.log(myCarEx01);//speed 150에서 10줄어든 140으로 변경확인
    myCarEx01.accelCar()//엑셀 함수 실행
    console.log(myCarEx01);//speed 140에서 10 늘어난 150으로 변경확인
  </script>
  <script>
    //생성자 함수를 이용한 객체 생성
    //장점 : 개발자가 원하는 개수만큼 객체를 쉽게 만들 수 있다.
    //개발 도중, 필요하지만 자바스크립트에서 지원하지않는 객체를 생성하고 싶을때 사용
    function MyCarEx02(model, speed, color) {//생성자 이름은 대문자로한다.
      this.model = model//this 키워드로 일반 변수와 객체 속성을 구별
      this.speed = speed
      this.color = color
      this.brake = function () { this.speed -= 10 }//객체의 메서드
      this.accel = function () { this.speed += 10 }
    }
    let myCarEx02 = new MyCarEx02(`avante`, `170`, `white`);
    console.log(myCarEx02);
    myCarEx02.color = `black`
    console.log(myCarEx02);
    myCarEx02.brake()
    console.log(myCarEx02);
    myCarEx02.accel()
    console.log(myCarEx02);
    myCarEx02.turbo = true //객체에 새로운 속성 추가 
    console.log(myCarEx02);
    myCarEx02.showModel = function () { //객체에 새로운 메서드 추가
      document.write(`<hr>`)
      document.write(`해당 자동차는 아반테입니다.`)
    }
    myCarEx02.showModel()
    //객체 멤버 - 객체 안의 속성과 메서드를 객체 멤버라고 함
  </script>
  <script>
    //자바스크립트에는 클래스가없다. 입력되는 즉시 실행해야하는 인터프리터 언어이기때문이다.
    //하지만 클래스의 역할을 하는 프로토 타입이있다. 이것을 클래스처럼 사용할 수 있다.
    //프로토타입 체인 - 자바스크립트에서 속성,메서드를 참조하게되면 다음과같다.
    //1) 객체 안에 속성이나 메서드가 정의되어있는지 체크
    //2) 객체 안에 정의되어있지 않으면 객체의 prototype이 속성이나 메서드를 가지고있는지 체크
    //3) 원하는 속성/메서드를 찾을때까지 프로토타입 체인을 따라 올라간다.
    //프로토타입 객체는 개별 객체에서 시작해 생성자의 프로토타입을 통해 object의 프로토타입까지 연결되어있다.
    function Point(xpos, ypos) {
      this.x = xpos;
      this.y = ypos;
    }
    Point.prototype.getDistance = function (p) { //모든 포인트 객체가 공유하는 메서드
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    let p1 = new Point(10, 20)
    let d1 = p1.getDistance()
    let p2 = new Point(10, 30)
    let d2 = p2.getDistance()
    document.write(`<br>`)
    document.write(`<hr>`)
    document.write(d1 + `<br>`)
    document.write(d2 + `<br>`)
    //Object 객체 - 자바스크립트 객체의 부모가 되는 객체.
    //constructor 속성 - 속성으로 생성자 함수를 가리킨다.
    document.write(`<hr>`)
    document.write(p1.constructor)
    document.write(`<hr>`)
    //valueOf() 메서드 - 메서드로서 객체를 숫자로 변환한다.
    //toString() 메서드 - // 객체의 값을 문자열로 변환
    //hasOwnProperty() - 전달 인수로 주어진 속성을 가지고있다면 true 반환
    //isPrototype() - 현재 객체가 전달 인수로 주어진 객체의 프로토타입이면 true 반환
    //Object 객체의 메서드는 하위 객체에서 재정의해서 아래와같이 사용 할 수 있다.
    Point.toString = function () {
      return `새로 정의된 객체입니다.`
    }
    document.write(`<br>`)
    document.write(Point.toString())
  </script>
  <script>
    //자바스크립트 내장 객체
    //1 - Date() : 날짜와 시간 작업을 하는데 사용되는 가장 기본적인 객체
    // Date 객체 생성자 4가지
    //1-1 : 현재 날짜와 시간 date
    let nowDateTime = new Date()
    document.write(`<hr>`)
    document.write(`<br>`)
    document.write(nowDateTime)
    //1-2 : Date(milliseconds) - 1999/01/01 이후의 밀리초 
    //let DateTimeMilli = new Date(milliseconds)
    document.write(`<br>`)
    //document.write(DateTimeMilli)
    //1-3 : Date(dateString) - 다양한 문자열
    //let DateString = new Date(dateString)
    document.write(`<br>`)
    //document.write(DateString)
    //1-4 : Date(year, month, date[, hours[, minutes[, seconds[,ms]]]])
    //Date() 주의 할 점은 월은 0부터 시작, 1월은 0으로 입력해줘야함 12월은 11 입력
    //Date 는 아주많은 메서드를 가지고있기에 작업할때 검색해서 필요한것을 사용하자
    //쇼핑몰에 구입한지 30일 지난물건은 교환이 안된다. 검사하는 프로그램을 만들어보자
    function cheackDate() {
      let userBuyDate = document.getElementById(`productDate`).value
      let pDate = new Date(userBuyDate)
      let today = new Date()
      let diff = today.getTime() - pDate.getTime() //날짜 간격 밀리초 단위 계산
      let days = Math.floor(diff / (1000 * 60 * 60 * 24)) // 밀리초 차이값 나눠서 날짜 간격 구하기
      if (days > 30) {
        confirm(`교환 기간이 지났습니다.`)
      } else {
        confirm(`교환 가능한 기간입니다`)
      }
    }
  </script>
  <script>
    //Number 객체 - Number객체는 수치형 값을 감싸서 객체로 만들어주는 랩퍼(wrapper) 객체다.
    //랩퍼 객체 - 수치값을 직접 사용할 수는 없고 , 반드시 객체가 필요한 경우에 사용
    let num = new Number()
    num = 1.234
    console.log(num.toString()); //이와 같이 1.234를 감싸는 랩퍼 객체 생성가능
    //Number 객체의 속성 중 일부 3가지
    //1) MAX VALUE - 표현 할 수 있는 가장큰값
    //2) MIN VALUE - 표현 할 수 있는 가장작은값
    //3) NaN - Not a Number 
    //Number 객체의 메서드 4가지
    //1) toExponential() - 지수형으로 반환 , 인수는 소수점 이하 숫자의 개수
    document.write(`<hr>`)
    let numProperty = 123.4567
    document.write(`1) toExponential() - 지수형으로 반환 , 인수는 소수점 이하 숫자의 개수` + `<br>`)
    document.write(numProperty.toExponential()+ `<br>`)
    document.write(numProperty.toExponential(1) + `<br>`)
    //2) toFixed() - 고정소수점 방식으로 반환, 인수는 소수점 이하 숫자의 개수
    let numProperty2 = 123.4567
    document.write(`2) toFixed() - 고정소수점 방식으로 반환, 인수는 소수점 이하 숫자의 개수` + `<br>`)
    document.write(numProperty2.toFixed() + `<br>`)
    document.write(numProperty2.toFixed(1) + `<br>`)
    //3) toPrecision() - 유효숫자 수를 지정
    let numProperty3 = 123.4567
    document.write(`3) toPrecision() - 유효숫자 수를 지정` + `<br>`)
    document.write(numProperty2.toPrecision(1) + `<br>`)
    document.write(numProperty2.toPrecision(2) + `<br>`)
    //4) toString() - 주어진 진법으로 숫자를 반환
    let numProperty4 = 123.4567
    document.write(`4) toString() - 주어진 진법으로 숫자를 반환` + `<br>`)
    document.write(numProperty2.toString() + `<br>`)
    document.write(numProperty2.toString(2) + `<br>`)
    document.write(numProperty2.toString(8) + `<br>`)
    document.write(numProperty2.toString(16) + `<br>`)
    document.write(`<hr>`)
  </script>
</head>

<body>
  <div>
    <form>
      구입 날짜 : <input id="productDate" type="date" value="">
      <button type="button" onclick="cheackDate()">검사</button>
    </form>
  </div>
  <hr>
  <div id="remaining">
  </div>
  <script>
    //카운트 다운 타이머를 만들어보자
    function datesUntilNewYear() {
      let now = new Date()
      let newYear = new Date(`January 1, ` + (now.getFullYear() + 1))
      let diff = newYear - now
      let milliseconds = Math.floor(diff % 1000)
      diff = diff / 1000
      let seconds = Math.floor(diff % 60)
      diff = diff / 60
      let minutes = Math.floor(diff % 60)
      diff = diff / 60
      let hours = Math.floor(diff % 24)
      diff = diff / 24
      let days = Math.floor(diff)

      let outStr = `내년 1월 1일까지 ` + days + `일, ` + hours + `시간, ` + minutes
      outStr += `분, ` + seconds + `초` + ` 남았습니다.`

      document.getElementById(`remaining`).innerHTML = outStr
      //1초가 지나면 다시 함수를 호출한다.
      setTimeout(`datesUntilNewYear()`, 1000)
    }
    // 타이머를 시작한다.
    datesUntilNewYear()
  </script>
  <hr>
  <div id="clock">
  </div>
  <script>
    // 현재 시간 시계 만들기
    function setClock() {
      let now = new Date()
      let s = now.getHours() + `:` + now.getMinutes() + `:` + now.getSeconds()
      document.getElementById(`clock`).innerHTML = s
      setTimeout(`setClock()`, 1000) //두번째 인수의 시간(밀리초)만큼 지난 후에 첫번째 인수를 호출, 여기서는 1초가 지난 후에 setClock() 호출
    }
    setClock()
  </script>
</body>

</html>